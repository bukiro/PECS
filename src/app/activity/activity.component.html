<ng-container
    *ngFor="let maxCharges of [activity.maxCharges(get_Creature(), characterService)]; trackBy: trackByIndex;">
    <ng-container
        *ngFor="let cooldown of [activity.get_Cooldown(get_Creature(), characterService)]; trackBy: trackByIndex;">
        <ng-container *ngFor="let activitySpell of [get_ActivitySpell()]; trackBy:trackByIndex">
            <!-- Targets if the activity is not a fuse stance and can be activated. Includes activities with no effect that can be toggled or have a cooldown. -->
            <div class="newrow" *ngIf="allowActivate && !get_ExternallyDisabled()">
                <ng-container *ngIf="gain.name != 'Fused Stance' && activity.can_Activate()">
                    <!-- Spell targets if a spell is cast by this activity -->
                    <ng-container *ngIf="activitySpell">
                        <app-spellTarget class="newrow vlist" [creature]="creature" [spell]="activitySpell.spell"
                            [phrase]="'Activate' + (maxCharges ? ' (' + (maxCharges - gain.chargesUsed) + ' of ' + maxCharges + ' charges)' : '') + ' and cast'"
                            [gain]="activitySpell.gain" [parentActivityGain]="gain"
                            [cannotCast]="gain.activeCooldown ? (maxCharges ? 'Recharged in: ' : 'Cooldown: ') + get_Duration(gain.activeCooldown, true, false) : ''"
                            [effectiveSpellLevel]="activitySpell.cast.level || activitySpell.spell.levelreq"
                            [showDismiss]="true" [dismissPhrase]="activity.sustained ? 'Stop Sustaining' : 'Deactivate'"
                            (castMessage)="on_Activate(gain, activity, $event.activated, $event.target)">
                        </app-spellTarget>
                    </ng-container>
                    <!-- Activity targets if no spell is cast -->
                    <ng-container *ngIf="!activitySpell">
                        <app-spellTarget class="newrow vlist" [creature]="creature" [activity]="activity"
                            [phrase]="'Activate' + (maxCharges ? ' (' + (maxCharges - gain.chargesUsed) + ' of ' + maxCharges + ' charges)' : '')"
                            [gain]="gain"
                            [cannotCast]="gain.activeCooldown ? (maxCharges ? 'Recharged in: ' : 'Cooldown: ') + get_Duration(gain.activeCooldown, true, false) : ''"
                            [effectiveSpellLevel]="get_Character().level" [showDismiss]="true"
                            [dismissPhrase]="activity.sustained ? 'Stop Sustaining' : 'Deactivate'"
                            (castMessage)="on_Activate(gain, activity, $event.activated, $event.target)">
                        </app-spellTarget>
                    </ng-container>
                </ng-container>
            </div>
            <ng-container *ngIf="allowActivate && !activitySpell">
                <!-- Fused Stance activation and deactivation -->
                <ng-container
                    *ngIf="gain.name == 'Fused Stance' && (gain.activeCooldown ? (maxCharges > gain.chargesUsed) : true)">
                    <div class="newrow"
                        [ngbTooltip]="gain.activeCooldown ? (maxCharges ? 'Recharged in: ' : 'Cooldown: ') + get_Duration(gain.activeCooldown, true, false) : ''"
                        *ngIf="!gain.active">
                        <button class="newrow center-aligned" (click)="on_ActivateFuseStance(true)"
                            [disabled]="!get_FuseStanceFeat() || !get_FuseStanceFeat().data">
                            Activate {{maxCharges ? "(" + (maxCharges - gain.chargesUsed) + " of " + maxCharges + "
                            charges)" : ""}}
                        </button>
                    </div>
                    <div class="newrow"
                        [ngbTooltip]="gain.activeCooldown ? (maxCharges ? 'Recharged in: ' : 'Cooldown: ') + get_Duration(gain.activeCooldown, true, false) : ''"
                        *ngIf="gain.active">
                        <button class="newrow center-aligned" (click)="on_ActivateFuseStance(false)"
                            [disabled]="!get_FuseStanceFeat() || !get_FuseStanceFeat().data">
                            Deactivate {{maxCharges ? "(" + (maxCharges - gain.chargesUsed) + " of " + maxCharges +
                            " charges)" : ""}}
                        </button>
                    </div>
                </ng-container>
                <!-- Activity with no effect, not even toggled. This button literally does nothing. -->
                <ng-container *ngIf="!get_ManualMode() && !activity.can_Activate()">
                    <button class="newrow center-aligned"
                        [ngbTooltip]="'The activity has no automatic effects and no target.'">
                        <span>Activate <i class='bi-peace'></i></span>
                    </button>
                </ng-container>
                <!-- Same button in manual mode, without the peace icon. -->
                <ng-container *ngIf="get_ManualMode() && !activity.can_Activate()">
                    <button class="newrow center-aligned">
                        <span>Activate</span>
                    </button>
                </ng-container>
                <!-- Activity disabled by effect -->
                <div class="newrow" *ngIf="get_ExternallyDisabled()">
                    <button class="newrow center-aligned" disabled>
                        Cannot activate (disabled by effect)
                    </button>
                </div>
                <!-- Unslotted Aeon Stone -->
                <div class="newrow" *ngIf="get_Resonant() && !isSubItem">
                    <strong>Slot this item into a Wayfinder to unlock its resonant power.</strong>
                </div>
            </ng-container>
            <!-- End cooldown and restore charges button in manual mode-->
            <ng-container *ngIf="get_ManualMode() && allowActivate && gain.activeCooldown">
                <button class="newrow center-aligned" (click)="on_ManualEndCooldown()">
                    <span>End cooldown</span>
                </button>
            </ng-container>
            <!-- Restore charges button in manual mode-->
            <ng-container *ngIf="get_ManualMode() && allowActivate && gain.chargesUsed">
                <button class="newrow center-aligned" (click)="on_ManualRestoreCharge()">
                    <span>Restore charge</span>
                </button>
            </ng-container>
        </ng-container>
        <div class="newrow left-aligned">
            <cite class="trait" *ngFor="let trait of activity.traits; trackBy:trackByIndex;"
                [ngbPopover]="get_Traits(trait)[0].desc">{{trait}}</cite>
            <cite class="trait" *ngFor="let trait of get_ActivationTraits(activity); trackBy:trackByIndex;"
                [ngbPopover]="get_Traits(trait)[0].desc">{{trait}}</cite>
            <app-tags [creature]="creature" [objectName]="activity.name" [showTraits]=true [showFeats]=true
                [showItems]=true [showActivities]=true [showConditions]=true [showEffects]=true></app-tags>
        </div>
        <ng-container
            *ngFor="let conditionSet of get_ActivityConditions(); let conditionSetIndex = index; trackBy:trackByIndex">
            <div class="newrow list-item left-aligned"
                *ngIf="conditionSet.condition.$choices.length && !conditionSet.gain.choiceBySubType && !conditionSet.gain.choiceLocked && !conditionSet.gain.copyChoiceFrom && !conditionSet.gain.hideChoices">
                <span>{{conditionSet.condition.name}} effect
                    selection:
                    <select [(ngModel)]="gain.effectChoices[conditionSetIndex].choice"
                        (ngModelChange)="on_EffectChoiceChange()">
                        <option *ngFor="let choice of conditionSet.condition.$choices; trackBy:trackByIndex;"
                            [ngValue]="choice">
                            {{choice}}
                        </option>
                    </select>
                </span>
            </div>
        </ng-container>
        <div class="list-item lower newrow problem" *ngIf="activity.inputRequired">
            <strong>Player input required:</strong>
            <div class="newrow left-aligned">
                <p *ngFor="let inputRequired of activity.inputRequired.split('\n'); trackBy:trackByIndex;">
                    {{inputRequired}}
                </p>
            </div>
        </div>
        <div class="newrow left-aligned"
            *ngIf="activity.frequency || ((cooldown != activity.cooldown) && !activity.cooldownAfterEnd)">
            <span>
                <strong>Frequency</strong>
                <span *ngIf="cooldown == activity.cooldown">&nbsp;{{activity.frequency}}</span>
                <span class="absolute" *ngIf="cooldown != activity.cooldown">&nbsp;{{maxCharges ? maxCharges + "
                    times every " : "once every "}}{{get_Duration(cooldown, false, false)}}</span>
            </span>
        </div>
        <div class="newrow left-aligned" *ngIf="cooldown && activity.cooldownAfterEnd">
            <span>
                <strong>Cooldown after use</strong>
                <span [ngClass]="{'absolute':cooldown != activity.cooldown}">&nbsp;{{get_Duration(cooldown, false,
                    false)}}</span>
            </span>
        </div>
        <div class="newrow left-aligned" *ngIf="activity.cost">
            <span>
                <strong>Cost</strong>
                {{activity.cost}}
            </span>
        </div>
        <div class="newrow left-aligned" *ngIf="activity.trigger">
            <span>
                <strong>Trigger</strong>
                {{activity.trigger}}
            </span>
        </div>
        <ng-container *ngIf="allowActivate && gain?.data">
            <div class="newrow left-aligned" *ngFor="let data of gain.data; trackBy:trackByIndex">
                <strong>{{data.name}}</strong>
                <input class="newrow" type="text" [(ngModel)]="data.value">
            </div>
        </ng-container>
        <div class="newrow left-aligned" *ngIf="activity.requirements">
            <span>
                <strong>Requirements</strong>
                {{activity.requirements}}
            </span>
        </div>
        <div class="newrow left-aligned" *ngFor="let desc of get_HeightenedDescription().split('\n\n'); trackBy:trackByIndex;">
            <app-description class="newrow" [text]="desc"></app-description>
        </div>
        <div class="newrow left-aligned" *ngIf="activity.critsuccess">
            <span>
                <strong>Critical Success</strong>
                <app-description [text]="activity.critsuccess" [oneLiner]="true"></app-description>
            </span>
        </div>
        <div class="newrow left-aligned" *ngIf="activity.success">
            <span>
                <strong>Success</strong>
                <app-description [text]="activity.success" [oneLiner]="true"></app-description>
            </span>
        </div>
        <div class="newrow left-aligned" *ngIf="activity.failure">
            <span>
                <strong>Failure</strong>
                <app-description [text]="activity.failure" [oneLiner]="true"></app-description>
            </span>
        </div>
        <div class="newrow left-aligned" *ngIf="activity.critfailure">
            <span>
                <strong>Critical Failure</strong>
                <app-description [text]="activity.critfailure" [oneLiner]="true"></app-description>
            </span>
        </div>
        <div class="newrow left-aligned" *ngIf="activity.specialdesc">
            <span>
                <strong>Special</strong>
                {{activity.specialdesc}}
            </span>
        </div>
        <div class="list-item left-aligned"
            *ngFor="let shownActivityName of activity.showActivities; trackBy:trackByIndex;">
            <div *ngFor="let shownActivity of get_Activities(shownActivityName); trackBy:trackByIndex;">
                <header class="spellHeader">
                    {{shownActivity.name}}
                    <app-actionIcons *ngIf="shownActivity.actions" [actionString]="shownActivity.actions">
                    </app-actionIcons>
                    {{shownActivity.activationType.toString()}}
                </header>
                <app-activity [activity]=shownActivity [allowActivate]="false"></app-activity>
            </div>
        </div>
        <div class="list-item newrow left-aligned"
            *ngFor="let cast of get_SpellCasts(); let spellCastIndex = index; trackBy:trackByIndex;">
            <div *ngFor="let spell of get_Spells(cast.name); trackBy:trackByIndex;">
                <header class="spellHeader">
                    {{spell.name}}
                    <app-actionIcons *ngIf="spell.actions" [actionString]="spell.actions">
                    </app-actionIcons>
                    {{spell.castType.toString()}}
                </header>
                <ng-container
                    *ngFor="let conditionSet of get_SpellConditions(cast, spellCastIndex); let conditionSetIndex = index; trackBy:trackByIndex">
                    <div class="newrow list-item left-aligned"
                        *ngIf="!cast.hideChoices.includes(conditionSet.condition.name) && conditionSet.condition.$choices.length && !conditionSet.gain.choiceBySubType && !conditionSet.gain.choiceLocked && !conditionSet.gain.copyChoiceFrom && !conditionSet.gain.hideChoices">
                        <span>{{conditionSet.condition.name}} effect selection:
                            <select [(ngModel)]="gain.spellEffectChoices[spellCastIndex][conditionSetIndex].choice"
                                (ngModelChange)="on_EffectChoiceChange()">
                                <option *ngFor="let choice of conditionSet.condition.$choices; trackBy:trackByIndex;"
                                    [ngValue]="choice">
                                    {{choice}}
                                </option>
                            </select>
                        </span>
                    </div>
                </ng-container>
                <app-spell class="fullwidth" [spell]=spell [spellLevel]="(cast.level) ? cast.level : 0"></app-spell>
            </div>
        </div>
        <div class="list-item left-aligned" *ngFor="let shownSpellSet of activity.showSpells; trackBy:trackByIndex;">
            <div *ngFor="let shownSpell of get_Spells(shownSpellSet.name); trackBy:trackByIndex;">
                <header class="spellHeader">
                    {{shownSpell.name}}
                    <app-actionIcons *ngIf="shownSpell.actions" [actionString]="shownSpell.actions">
                    </app-actionIcons>
                    {{shownSpell.castType.toString()}}
                </header>
                <app-spell class="fullwidth" [spell]=shownSpell [spellLevel]="shownSpellSet.level || 0"></app-spell>
            </div>
        </div>
        <div class="list-item newrow left-aligned"
            *ngFor="let feat of get_FeatsShowingOn(activity.name); trackBy:trackByIndex;">
            <header class="spellHeader">{{feat.name}}</header>
            <div class="newrow left-aligned">
                <cite class="trait" *ngFor="let trait of feat.traits; trackBy:trackByIndex;"
                    [ngbPopover]="get_Traits(trait)[0].desc">{{trait}}</cite>
            </div>
            <div class="newrow left-aligned" *ngFor="let desc of feat.desc.split('\n\n'); trackBy:trackByIndex;">
                <app-description class="newrow" [text]="desc"></app-description>
            </div>
        </div>
        <div class="newrow left-aligned"
            *ngFor="let conditionSet of get_ConditionsShowingOn(activity.name); trackBy:trackByIndex;">
            <header class="spellHeader">{{conditionSet.condition.name}}</header>
            <div class="newrow left-aligned"
                *ngFor="let desc of conditionSet.condition.get_Heightened(conditionSet.condition.desc, conditionSet.gain.heightened).split('\n\n'); trackBy:trackByIndex;">
                <app-description class="newrow" [text]="desc"></app-description>
            </div>
        </div>
        <ng-container *ngIf="allowActivate">
            <ng-container *ngFor="let related_gain of get_ActivityGainsShowingOn(activity.name); trackBy:trackByIndex;">
                <div class="list-item newrow left-aligned"
                    *ngFor="let related_activity of get_ActivitiesFromGain(related_gain); trackBy:trackByIndex;">
                    <header class="spellHeader">
                        {{related_activity.name}}
                        <app-actionIcons *ngIf="related_activity.actions" [actionString]="related_activity.actions">
                        </app-actionIcons>
                        {{(related_activity.activationType) ? related_activity.activationType : ""}}
                    </header>
                    <app-activity [creature]="creature" [activity]=related_activity [gain]=related_gain
                        [allowActivate]=true></app-activity>
                </div>
            </ng-container>
            <ng-container *ngIf="gain.name == 'Fused Stance'">
                <ng-container *ngFor="let gain of get_FusedStances(); trackBy:trackByIndex;">
                    <div class="list-item newrow left-aligned"
                        *ngFor="let related_activity of get_ActivitiesFromGain(gain); trackBy:trackByIndex;">
                        <header class="spellHeader">
                            {{related_activity.name}}
                            <app-actionIcons *ngIf="related_activity.actions" [actionString]="related_activity.actions">
                            </app-actionIcons>
                            {{(related_activity.activationType) ? related_activity.activationType : ""}}
                        </header>
                        <app-activity [creature]="creature" [activity]=related_activity [gain]=gain
                            [allowActivate]=false>
                        </app-activity>
                    </div>
                </ng-container>
            </ng-container>
        </ng-container>
    </ng-container>
</ng-container>